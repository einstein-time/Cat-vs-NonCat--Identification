We are going to define the following functions.

Sigmoid Function - calculates the sigmoid activation function
Initialize Weights - initializes the weights and bias values to zeros, upon which we update those values through optimization
Forward propagation - returns activations and cost
Backward propagation - returns the gradients(derivatives) of weights and bias
Propagate - implements the forward and backward propagation by calling the corresponding functions
Predict - predicts the labels
Get Accuracies - calculates the accuracies of predictions of the model
Optimize - gets the optimal weights and biases
Model - the main function to train the algorithm and get the final model for classification.

np.exp() calculates the exponent value of each element of the input array.

np.linspace(a,b,n) returns a NumPy array with n equally spaced elements, and a and b are respectively the first and last elements in the resultant array.

np.dot(a,b) calculates the dot product of the two vectors a and b.
np.random.seed(0) makes sure that the same set of random numbers are generated, no matter how many times the code is run.
Using np.random.rand, we could generate a matrix of any given shape filled with some random numbers ranging in [0, 1).

np.log calculates the natural logarithm of all the elements in the array.

np.dot(a,b) calculates the dot product of the two vectors a and b.

np.sum(x) calculates the sum of elements in the input array.

